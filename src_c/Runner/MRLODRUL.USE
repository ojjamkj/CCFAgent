#include    <stdio.h>                                                
#include    <stdlib.h>
#include    <ctype.h>
#include    <string.h>

#include    "MRCSComm.h"
#include    "MTUtil.h"
#include    "MTCtSect.h"
#include    "BREXLog.h"

#include    "MRLODRUL.h"
#include    "MRTOKEN.h"
#include    "MRSTRUCT.h"
#include    "MRPARSE.h"
#include    "MRDEFINE.h"
#include    "MRDTypes.h"

#include    "MRDTLIST.h"
#include    "MRGBLVAR.h"

#include    "BRTrace.h"

CMTCriticalSection      m_sect;

#ifdef _DB2
    #define      SQLMESSAGE ((char*)sqlca.sqlerrmc)
    #define      SQLCODE    sqlca.sqlcode
    #define      NOTFOUND   100
    #define      SQL_DUP   -803
    
    #define sql_context void*
    
    sql_context     ctxLoad;
#endif

#ifdef _ORACLE
    #define	     SQLMESSAGE	((char*)sqlca.sqlerrm.sqlerrmc)
    #define      SQLCODE    sqlca.sqlcode
    #define      NOTFOUND   1403

	EXEC SQL BEGIN DECLARE SECTION; 
		sql_context     ctxLoad; 
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctxLoad;
	
#endif
extern char               _DBPASSWORD[201]; //  QUALIFIER
extern char               _DBPWD_ENC[3]; //  ENC
	

EXEC SQL BEGIN DECLARE SECTION;
    char         RS40_1[21];         // Pgm Id
    _SQLINT      RS40_2;             // Start Rule Id
    _SQLINT      RS40_3;             // Max Ret Count  
    short        RS40_4;             // Parm구분 : 1.Object  2.Stream
    _SQLINT      RS40_5;             // 실행기준일 ItemCd
    
    _SQLINT      RS41_2;             // Item Cd
    short        RS41_3;             // Item Type
    short        RS41_4;             // Level    
    short        RS41_5;             // L1
    short        RS41_6;             // L2
    short        RS41_7;             // Max Occ
    _SQLINT      RS41_8;             // Occ-Item Cd
	char         RS11_2[200+1];      // Item Name
	char		 RS32_2[200+1];      // Rule Name

    _SQLINT      RS43_1;             // Rule No
    short        RS43_2;             // Rule 형태
    char         RS43_3[201];        // Branch Name
    short        RS43_4;             // Preload
    short        RS43_5;             // reRun 여부
    short        RS43_6;             // Break 여부
    short        RS43_7;			 // Agg_Option  
	char         RS43_8[31];         // Group    
    char		 RS43_9[31];         // 정렬방법
	char		 RS43_A[201];        // Default
	short		 RS43_B;			 // Static여부

	double		 RS44_1;
	
	char		 RS44_2[9];          // Start Date
	char		 RS44_3[9];          // End Date
	short        RS44_4;             // Sort여부
	
	short        RS45_1;             // Seq
    char         RS45_2[1001];       // Result

	short		 RS4A_1;
    char         RS4A_2[1001];       // Value1
    char         RS4A_3[1001];       // Value2

    short        RS48_1;             // SEQ
    short        RS48_2;             // Gbn
    char		 RS48_3[1001];		 // Expression

	short        RS4D_2;             // Seq
    char         RS4D_3[101];        // 판단값
    
EXEC SQL END DECLARE SECTION;	


CMRLoadData *pCMRLoadData;

extern  PGM_LIST      *pPgmList;
extern  RULE_LIST     *pRuleList;

long		rId_RuleName;
long		rId_DAMBOLIST;
long		rId_DAMBOGM;
long		rConf_DAMBO_POS;
long		rConf_DAMBO_LENG;
int         isConnected;

long  AllocThreadCtx( void ** );
void  FreeCtx( void ** );
long  AttatchThreadCtx( void *, char * );
int   DetachThreadCtx( void * );
int   ConnectDatabase( void *, char*);
void  DisconnectDatabase( void * );


#ifdef	_TRACE
extern	CBRTrace	*g_pCBRTrace;
#endif


int ConnectLoadDatabase( char *msg )
{
    struct sqlca    sqlca;
	if( isConnected == 1) {
		#ifndef _OS390
			if ( AttatchThreadCtx( ctxLoad, msg ) != 0 ) return -1;
		#endif

			EXEC SQL
					SELECT     COUNT(*)
					INTO      :RS40_2
					FROM       BRS120TB;

			if ( SQLCODE == 0 ) {
				return 0;
			}
	}
    if ( ConnectDatabase( ctxLoad, msg ) != 0 ) {
    
#ifndef _OS390
		DetachThreadCtx( ctxLoad );
#endif
		isConnected = 0;
		return -1;
	}
	isConnected = 1 ;
    return 0;
}

void DisConnectLoadDatabase()
{
#ifdef _OS390
    struct sqlca    sqlca;
	EXEC SQL COMMIT;
#else
	DetachThreadCtx(ctxLoad);
#endif

}


void  DB_Lock()
{
	m_sect.Lock();
}

void  DB_Unlock()
{
	m_sect.Unlock();
}


void   BuildDataStructure()
{
    char   msg[256];
    struct sqlca    sqlca;    


#ifndef _OS390
	long rc;
    if ( (rc = AllocThreadCtx( &ctxLoad )) != 0 ) {
        printf("AllocThreadCtx Error(%d).\n", rc );
        exit(0);
    }
#endif
		

    if ( ConnectDatabase( ctxLoad, msg ) != 0 ) {
		isConnected = 0 ;
		printf("===> %s\n\n", msg );
		exit(0);
	}
	isConnected = 1 ;
//printf("ctxLoad :%x!\n", ctxLoad );


	pCMRGblVars = new CMRGblVars();

	pCMRLoadData = new CMRLoadData();
	
#ifdef	_TRACE	
	g_pCBRTrace = new CBRTrace();
#endif


/***************************************************/
/**   READ CONFIGURATION   *************************/

	pCMRLoadData->BuildConfiguration();

	g_pCBREXLog = new CBREXLog();
	
	_WriteLogNo( _LOG_LOG, "\n**************************************************\n" );
	_WriteLog( _LOG_LOG, "BRMiner Engine Start.\n" );
		
	configParm->DisplayConfigParm();

/***************************************************/

    _WriteLogNo( _LOG_LOG, "**************************************************"); 
    _WriteLog( _LOG_LOG, "Start Loading." ); 
            
    pCMRLoadData->BuildDataStructure();

	EXEC SQL ROLLBACK;

    DisConnectLoadDatabase();

    _WriteLogNo( _LOG_LOG, "**************************************************\n");  
}


//extern unsigned char    bIndexUsed;
extern char             UsedIndex[5];

/**********************************************************************/
//  Running시 Load안된놈, Deploy로 삭제된놈 Load 
int CMRLoadData::ReloadRuleBody( RULE_LIST *pRule )
{
    int    rc = 0;
	char   msg[255];

	if ( pRule->loaded == 'X' )	return -1;
	
//printf("here 0\n");
    m_sect.Lock();
    
//printf("here 1\n");
	if ( pRule->loaded == 'N' ) {

		if ( ConnectLoadDatabase( msg ) != 0 ) {
			m_sect.Unlock();
			return -1;
		}
//printf("after conn\n");
//		bIndexUsed = 0;
		strcpy(UsedIndex,"_NNN");

    	rc = LoadRuleBody( pRule );
//printf("aft load : %d\n", rc);

		DisConnectLoadDatabase();
	}

    m_sect.Unlock();

    return rc;
}

/**********************************************************************/

CMRLoadData::CMRLoadData()
{
    pgmCnt = 0;
    readRuleCnt = 0;
	readRuleBodyCnt = 0;
}

CMRLoadData::~CMRLoadData()
{
//      freeRuleNode( pRuleList );
}


void CMRLoadData::ChkDBError( struct sqlca sqlca, 
                             const char* sPosition )                 
{
    if( SQLCODE != 0 && SQLCODE != NOTFOUND ) {
        printf("SQL ERROR.\n");
        printf("    %s (%d) : %s\n", sPosition, SQLCODE, SQLMESSAGE );
        throw new CMTException( UERR_DBERROR, sPosition );  
    }
}


void   CMRLoadData::BuildDataStructure()
{                                           
    char msg[128];
    
    BuildPgmStruct();

    BuildRuleStruct();

	BuildNameList();

    BuildDataBaseStruct();

    _WriteLogNo( _LOG_LOG, " " );
    _WriteLog( _LOG_LOG, "End Loading." ); 
    _WriteLogNo( _LOG_LOG, "**************************************************\n");

    sprintf( msg, "Program Loaded : %d", pgmCnt );
    _WriteLogNo( _LOG_LOG, msg );
    sprintf( msg, "Rule    Loaded : Header(%d)  Body(%d)\n", readRuleCnt, readRuleBodyCnt );
    _WriteLogNo( _LOG_LOG, msg );

	pCMRGblVars->DisplayAllocSize( msg );
    _WriteLogNo( _LOG_LOG, msg );
    
/*    
    printf( "     Conditional Rule : %d\n", cRuleCnt );     
    printf( "     Query       Rule : %d\n", qRuleCnt );     
    printf( "     Brench      Rule : %d\n", bRuleCnt );     
    printf( "     External    Rule : %d\n", eRuleCnt );     
*/
         
}


void   CMRLoadData::BuildPgmStruct( void )
{

// PGM LIST
EXEC SQL DECLARE Cursor_PgmList CURSOR FOR
         SELECT     RS40_1, RS40_2, RS40_3, RS40_4
         FROM       BRS400TB
         ORDER BY   RS40_1  ASC;

    struct sqlca    sqlca;
    PGM_LIST       *pPgmPtr;
    
	pgmCnt = 0;

    EXEC SQL  OPEN  Cursor_PgmList;

    ChkDBError( sqlca, "BuildPgmStruct( Cursor Open )" );

    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_PgmList
            INTO        :RS40_1, :RS40_2, :RS40_3, :RS40_4;

        ChkDBError( sqlca, "Fetch Cursor_PgmList" );
        if ( SQLCODE == NOTFOUND ) break;
        
        if ( ! pPgmList ) {
            pPgmPtr = (PGM_LIST *)
				pCMRGblVars->MetisAlloc( sizeof(PGM_LIST) );
                        
            pPgmList = pPgmPtr;
        } else {
            pPgmPtr->pNext = (PGM_LIST *)
				pCMRGblVars->MetisAlloc( sizeof(PGM_LIST) );
                        
            pPgmPtr = pPgmPtr->pNext;
        }

		//  PGM ID는 10자리만 가능함
		RS40_1[10] = 0;
		
        strcpy( pPgmPtr->PgmId, rtrim(RS40_1) );
        pPgmPtr->startRuleId = RS40_2;
        pPgmPtr->maxRowCnt = (short) RS40_3;
        pPgmPtr->itemCnt = 0;
        pPgmPtr->ParmGbn = RS40_4 + '0';
        pPgmPtr->pParm = 0;

        pPgmPtr->hit = 0;
        pPgmPtr->totTm = 0.0;
        pPgmPtr->totWait = 0.0;        
        pPgmPtr->maxTm = 0;
        
        pPgmPtr->pNext = 0;
        pgmCnt ++;
    
    }   

    EXEC SQL CLOSE Cursor_PgmList;


//printf("build Parm\n");

	
	pPgmPtr = pPgmList;
	while ( pPgmPtr ) {
//printf("   %s  ParmType = %c\n", pPgmPtr->PgmId, pPgmPtr->ParmGbn );

		if ( pPgmPtr->ParmGbn == '1' ) {    //  Object일때
			if ( BuildObjParms( pPgmPtr ) != 0 ) return;
		} else {                          //  STREAM일때
			if ( BuildStreamParms( pPgmPtr ) != 0 ) return;
		}
		pPgmPtr = pPgmPtr->pNext;
	}

}


int   CMRLoadData::BuildStreamParms( PGM_LIST *pPgmPtr )
{
	EXEC SQL DECLARE Cursor_PgmParm CURSOR FOR         
		 SELECT     A.RS41_2, A.RS41_3, A.RS41_4, A.RS41_5, A.RS41_6, A.RS41_7, A.RS41_8, NVL(B.RS11_2,' ' )
         FROM       BRS410TB A, BRS110TB B
         WHERE      A.RS40_1    =  :RS40_1
         AND        B.RS11_1(+) = A.RS41_2
         ORDER BY   A.RS41_1  ASC;
    struct sqlca    sqlca;
    PGM_PARM       *p1, *p2, *q;

	strcpy( RS40_1, pPgmPtr->PgmId );
    EXEC SQL  OPEN  Cursor_PgmParm;

    ChkDBError( sqlca, "BuildStreamParms( Cursor Open )" );

    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_PgmParm
            INTO        :RS41_2, :RS41_3, :RS41_4, :RS41_5, :RS41_6, :RS41_7, :RS41_8, :RS11_2;

        ChkDBError( sqlca, "Fetch Cursor_PgmParm" );
        if ( SQLCODE == NOTFOUND ) break;
        
        q = (PGM_PARM *) pCMRGblVars->MetisAlloc( sizeof(PGM_PARM) );
		q->itemCode = RS41_2;
		q->itemType = (char) RS41_3;
		strcpy(q->itemName,McRTrim(RS11_2)); 
#ifdef _KDB40
		q->itemName[60]=0;  
#else
		q->itemName[200]=0;  
#endif		
		     
		q->L1 = RS41_5;
		q->L2 = RS41_6;
		q->MaxOcc = RS41_7;
		q->ValidOcc_Icd = RS41_8;
		q->pNext = 0;
		q->pChild = 0;

        if ( RS41_2 > 0 ) pPgmPtr->itemCnt ++;
                
                
        if ( ! pPgmPtr->pParm ) {
			pPgmPtr->pParm = p1 = q;
			p2 = 0;
			continue;
		}
		
        if ( RS41_4 == 1 ) {
			p1->pNext = q;
			p1 = q;
			p2 = 0;
        } else {
			if ( p2 == 0 ) {
				p1->pChild = q;
				p2 = q;
			} else {
				p2->pNext = q;
				p2 = q;
			}
		}
    }   

    EXEC SQL CLOSE Cursor_PgmParm;

	return 0;
}

int   CMRLoadData::BuildObjParms( PGM_LIST *pPgmPtr )
{
EXEC SQL DECLARE Cursor_PgmParm2 CURSOR FOR
         SELECT     A.RS41_2, A.RS41_3, NVL(B.RS11_2,' ') 
         FROM       BRS410TB A, BRS110TB B
         WHERE      A.RS40_1 = :RS40_1
		 AND        B.RS11_1(+) = A.RS41_2 
         ORDER BY   A.RS41_1  ASC;

    struct sqlca    sqlca;
    ITEM_INFO	   *pItem;

	strcpy( RS40_1, pPgmPtr->PgmId );
	
	EXEC SQL
         SELECT     COUNT(*)
         INTO      :RS41_2
         FROM       BRS410TB
         WHERE      RS40_1 = :RS40_1;

    ChkDBError( sqlca, "BuildObjParms( Cursor Open )" );
    
	pPgmPtr->itemCnt = (short) RS41_2;

//printf("ITEMS = %d\n", RS41_2 );
	
	if ( RS41_2 == 0 ) return 0;
	
	
    pItem = (ITEM_INFO *) pCMRGblVars->MetisAlloc( sizeof(ITEM_INFO) * RS41_2 );
    pPgmPtr->pParm = pItem;
         	
    EXEC SQL  OPEN  Cursor_PgmParm2;

    ChkDBError( sqlca, "BuildObjParms( Cursor Open )" );

	int idx = 0;
	
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_PgmParm2
            INTO        :RS41_2, :RS41_3, :RS11_2;

        ChkDBError( sqlca, "Fetch Cursor_PgmParm" );
        if ( SQLCODE == NOTFOUND ) break;
        
//printf("   ITEM : %d %d\n",  RS41_2, RS41_3 );
      
		pItem[idx].itemCode = RS41_2;
		pItem[idx].itemType = (unsigned char) RS41_3;
		strcpy(pItem[idx].itemName,McRTrim(RS11_2));
#ifdef _KDB40
		pItem[idx].itemName[60]=0;
#else
		pItem[idx].itemName[200]=0;
#endif		
		idx++;
    }   

    EXEC SQL CLOSE Cursor_PgmParm2;

	return 0;
}


void   CMRLoadData::BuildRuleStruct( void )
{
// RULE LIST

EXEC SQL DECLARE Cursor_RuleList CURSOR FOR
         SELECT     A.RS43_1, A.RS43_2, A.RS43_3, A.RS43_4, A.RS43_5,
                    A.RS43_6, A.RS43_7, A.RS43_8, A.RS43_9, A.RS43_A, A.RS43_B,
                    NVL(B.RS32_2,' ')
         FROM       BRS430TB A, BRS320TB B
         WHERE      B.RS31_1(+) = A.RS43_1
         AND        B.RS32_1(+) = A.RS43_C
         ORDER BY   A.RS43_1  ASC;
/*
EXEC SQL DECLARE Cursor_RuleList CURSOR FOR
         SELECT     RS43_1, RS43_2, RS43_3, RS43_4, RS43_5,
		            RS43_6, RS43_7, RS43_8, RS43_9, RS43_A, RS43_B
         FROM       BRS430TB
         ORDER BY   RS43_1  ASC;

*/

EXEC SQL BEGIN DECLARE SECTION;
    _SQLINT		CNT;
EXEC SQL END   DECLARE SECTION;
	
	
    struct sqlca    sqlca;
    RULE_LIST      *pRulePtr;
	int				idx;
	char			msg[200];
	int				rc;

	EXEC SQL
         SELECT     COUNT(*)
		 INTO       :CNT
         FROM       BRS430TB;

	ChkDBError( sqlca, "BuildRuleStructure( Read Rule Count )" );

//printf("CNT = %d\n", CNT );

	if ( CNT == 0 ) return;

    pCMRGblVars->CreateRuleList( CNT );

    EXEC SQL  OPEN  Cursor_RuleList;

    ChkDBError( sqlca, "BuildRuleStructure( Cursor Open )" );

	if ( CNT >= 1 ) {
		sprintf(msg, "\n   Loading %d Rules.\n", CNT);
		_WriteLogNo( _LOG_LOG, msg );
	}
	
	idx = 0;
    while( 1 )
    {        
        EXEC SQL
            FETCH       Cursor_RuleList
            INTO        :RS43_1, :RS43_2, :RS43_3, :RS43_4, :RS43_5,
                        :RS43_6, :RS43_7, :RS43_8, :RS43_9, :RS43_A, :RS43_B,
						:RS32_2;

        ChkDBError( sqlca, "Fetch Cursor_RuleList" );
        if ( SQLCODE == NOTFOUND ) break; 

#ifdef _DEBUG
//		sprintf(msg, "RuleId = %d   type(%d)", RS43_1, RS43_2 );
//		_WriteLogNo( _LOG_LOG, msg );
#endif
				
		pRulePtr = & pRuleList[idx];

        pRulePtr->rule_id = RS43_1;
        pRulePtr->pVers = 0;
        pRulePtr->branchIdx = -1;
		strcpy(pRulePtr->ruleName,McRTrim(RS32_2));

#ifdef _KDB40
		pRulePtr->ruleName[60]=0;
#else
		pRulePtr->ruleName[200]=0;
#endif		
		
		        
		rc = LoadRuleHeader( pRulePtr, msg );
		
		if ( rc != 0 ) {
			pRulePtr->loaded = 'X';
			
			if ( rc < -1 ) throw new CMTException( UERR_DBERROR, msg );
		}

		idx ++;

		if ( idx % 1000 == 0 ) {
			sprintf( msg, "      %5d Headers.", idx);
			_WriteLogNo( _LOG_LOG, msg ); 
		}
    }
       
    EXEC SQL CLOSE Cursor_RuleList;

	readRuleCnt = idx;

#ifdef _DEBUG
//		_WriteLogNo( _LOG_LOG, "Load Header Successful." );
#endif

	if ( configRec.PreLoad[0] == 'N' ) return;


	for (idx=0; idx<readRuleCnt; idx++) {
					
		pRulePtr = &pRuleList[idx];

		if ( pRulePtr->loaded == 'X' ) continue;
		
        if ( pRulePtr->preLoad || configRec.PreLoad[0] == 'A' )
        {

#ifdef _DEBUG
//            _WriteLogNo( _LOG_LOG, "===========================================" );
#endif
		
            if ( LoadRuleBody( pRulePtr ) != 0 )
            {
                printf(m_errMessage);
//              throw new CMTException( UERR_DBERROR, EMSG_DBERROR );           
            } else {
				readRuleBodyCnt++;

			}
        }
    }
    
#ifdef _DEBUG
   _WriteLogNo( _LOG_LOG, "===========================================" );
#endif
    
}



int CMRLoadData::LoadRuleHeader( RULE_LIST *pHead,
								 char *errMessage )
{
	int rc;
	
	if ( pHead->pVers ) pHead->loaded = 'Y';
	else pHead->loaded = 'N';

	McRTrim(RS43_3);   	rtrim(RS43_A);
		
	pHead->r_type = (unsigned char) RS43_2;
	pHead->s_type = (unsigned char) 0;

	pHead->scope = RS43_B;	//  static 여부
	pHead->preLoad = RS43_4;
	pHead->breakFlag = RS43_6;
	
	pHead->parmType = (char *) 0;
	pHead->dftResult = 0;
	
	pHead->hit = 0;
	pHead->totTm = 0.0;
	pHead->maxTm = 0;
	
	//  Aggr Option
	pHead->pAggr = LoadRuleAggr();

	if ( (rc=LoadRuleReturn( pHead )) != 0 ) {
		strcpy( errMessage, m_errMessage );
		return rc;
	}


	if ( RS43_A[0] ) {
		int gbn;
		pHead->dftResult = buildDefaultResult( RS43_A, pHead, & gbn );
		//  0:Rule,Item포함  1:상수Only  2:Array  -1:Error
//		if ( gbn < 0 ) {
		if ( gbn != 1 ) {
			sprintf( errMessage, "  NRF expression parsing error (%d).",
				     pHead->rule_id );
			pHead->dftResult = 0;
			return -1;
		}
	}
	
	return 0;
}



RULE_AGGR * CMRLoadData::LoadRuleAggr()
{
	RULE_AGGR *pAggr;

	rtrim(RS43_8);   rtrim(RS43_9);
		
	if ( RS43_7 == 0 && RS43_9[0] == 0 ) return 0;

	pAggr = (RULE_AGGR *) pCMRGblVars->MetisAlloc( sizeof(RULE_AGGR) );

	pAggr->Option = RS43_7;
	strcpy(pAggr->group, RS43_8);


	int n = 0, idx;
	char *p;
	
	p = RS43_9;
	
	while ( *p ) {
		while ( *p ) { if (isgraph( *p ) ) break;   p++; }

		idx = 0;
		while ( *p >= '0' && *p <= '9' ) {
			idx = idx * 10 + (*p - '0');
			p ++;
		}
		
		pAggr->nSort[n] = idx;
		pAggr->cOrder[n] = 'A';
		if ( *p == 'D' || *p == 'A' ) pAggr->cOrder[n] = *p++;
		
		while ( *p ) { if ( isgraph(*p) ) break;   p++; }
		
		if ( *p == ',' ) p++;

		n++;		
	}

	pAggr->nSort[n] = 0;
    
	return pAggr;
}


void   CMRLoadData::BuildNameList( void )
{
// RULE LIST
EXEC SQL DECLARE Cursor_NameList CURSOR FOR
         SELECT     RS43_1, RS43_3
         FROM       BRS430TB
         WHERE		RS43_3 > ' '
         ORDER BY   RS43_3  ASC;

EXEC SQL BEGIN DECLARE SECTION;
    _SQLINT		CNT2;
EXEC SQL END   DECLARE SECTION;
	
	
    struct sqlca    sqlca;
    RULE_LIST      *pRulePtr;

	EXEC SQL
         SELECT     COUNT(*)
		 INTO       :CNT2
         FROM       BRS430TB
         WHERE		RS43_3 > ' ';

	ChkDBError( sqlca, "BuildNameList( Read Rule Count )" );

	readBranchCnt = CNT2;
	
	if ( CNT2 == 0 ) return;

    pCMRGblVars->SetBufferSize( CNT2 );

    EXEC SQL  OPEN  Cursor_NameList;

    ChkDBError( sqlca, "BuildNameList( Cursor Open )" );


    while( 1 )
    {        
        EXEC SQL
            FETCH       Cursor_NameList
            INTO        :RS43_1, :RS43_3;

        ChkDBError( sqlca, "Fetch BuildNameList" );
        if ( SQLCODE == NOTFOUND ) break;
           

		rtrim(RS43_3);
		if ( RS43_3[0] == 0 ) continue;

		try {
				pRulePtr = pCMRGblVars->SearchById( RS43_1 );
				
				pCMRGblVars->AddRuleNodeLast( RS43_3, pRulePtr );
				
		} catch( CMTException *e )
		{
				char msg[300];
				sprintf(msg, "Rule(%d) : %s\n", RS43_1, (char *) e->GetEMessage() );
				_WriteLogNo( _LOG_LOG, " " );
				_WriteLog( _LOG_LOG, msg );
				e->Delete();
		}
    }
       
    EXEC SQL CLOSE Cursor_NameList;

    
#ifdef _DEBUG
   _WriteLogNo( _LOG_LOG, "===========================================" );
#endif
    
}



//   Deploy시에만 Reload
int   CMRLoadData::ReloadPgmById( char *pgmId, char *errMessage )
{
    struct sqlca    sqlca;
    PGM_LIST       *pPgmPtr, *pPrevPtr;
    int             cmp;
    bool			bFound = false;

    strcpy( RS40_1, pgmId );

    EXEC SQL
         SELECT     RS40_2, RS40_3, RS40_4
         INTO      :RS40_2, :RS40_3, :RS40_4
         FROM       BRS400TB
         WHERE      RS40_1 = :RS40_1;

    if ( SQLCODE != 0 ) {
        sprintf( errMessage, "Select error (%d) : %s",
                 SQLCODE, SQLMESSAGE );
    
        return -1;
    }


	pPrevPtr = 0;
    pPgmPtr = pPgmList;
    while ( pPgmPtr ) {
        cmp = strcmp(pgmId, pPgmPtr->PgmId );

        if ( cmp == 0 ) {
			bFound = true;
			pPrevPtr = pPgmPtr;
            break;
        }

        if ( cmp < 0 ) break;

        pPrevPtr = pPgmPtr;
        pPgmPtr = pPgmPtr->pNext;
    }


    if ( ! bFound ) {    
		if ( ! pPgmList ) {
			pPrevPtr = (PGM_LIST *)	pCMRGblVars->MetisAlloc( sizeof(PGM_LIST) );
			pPrevPtr->pNext = 0;
			pPgmList = pPrevPtr;
		} else {
			if ( pPrevPtr == 0 ) {
				pPrevPtr = (PGM_LIST *)	pCMRGblVars->MetisAlloc( sizeof(PGM_LIST) );
				pPrevPtr->pNext = pPgmList;
				pPgmList = pPrevPtr;            
			} else {
				pPrevPtr->pNext = (PGM_LIST *) pCMRGblVars->MetisAlloc( sizeof(PGM_LIST) );
				pPrevPtr = pPrevPtr->pNext;
				pPrevPtr->pNext = pPgmPtr;
			}
		}

		strcpy( pPrevPtr->PgmId, pgmId );
		

		pPrevPtr->hit = 0;
		pPrevPtr->totTm = 0.0;
		pPrevPtr->maxTm = 0;		

		pPrevPtr->totWait =0.0;  
    }


    pPrevPtr->startRuleId = RS40_2;
    pPrevPtr->maxRowCnt = (short) RS40_3;
    pPrevPtr->itemCnt = 0;
    pPrevPtr->ParmGbn = RS40_4 + '0';
    pPrevPtr->pParm = 0;

	if ( pPrevPtr->ParmGbn == '1' ) {  //  Object일때
		if ( BuildObjParms( pPrevPtr ) != 0 ) return -1;
	} else {                          //  STREAM일때
		if ( BuildStreamParms( pPrevPtr ) != 0 ) return -1;
	}

    return 0;
}


    
//  Deploy시 Header Reload
int CMRLoadData::ReloadRuleHeader( RULE_LIST *pNodeNew,
								 char *errMessage )
{
    struct sqlca    sqlca;

    RS43_1 = pNodeNew->rule_id;

    EXEC SQL
        SELECT     RS43_2, RS43_3, RS43_4, RS43_5, RS43_6,
                   RS43_7, RS43_8, RS43_9, RS43_A, RS43_B
		INTO      :RS43_2, :RS43_3, :RS43_4, :RS43_5, :RS43_6,
				  :RS43_7, :RS43_8, :RS43_9, :RS43_A, :RS43_B
        FROM       BRS430TB
        WHERE       RS43_1 = :RS43_1;

    if ( SQLCODE != 0 ) {
        sprintf( errMessage, "Select error (%d) : %s",
                 SQLCODE, SQLMESSAGE );
        pNodeNew->loaded = 'X';
        return -1;
    }

	if ( LoadRuleHeader( pNodeNew, errMessage ) != 0 ) {
		pNodeNew->loaded = 'X';
		return -1;
	}


	//   기존 Node삭제
	//       없었으면(-1) : rc = 0
	//       명칭동일     : rc = 1   삭제안함
	//       명칭변경     : rc = 0   삭제됨
	//
	int rc = pCMRGblVars->DeleteNode( pNodeNew->branchIdx, RS43_3 );
	if ( rc < 0 ) {
		strcpy(errMessage, "Branchname index error." );
		pNodeNew->loaded = 'X';
		return -1;
	}
	
	if ( rc == 1 ) return 0;

	pNodeNew->branchIdx = -1;
				
	if ( RS43_3[0] ) {       //  Branch Name 있을때
		try {
			pCMRGblVars->AddRuleNodeSearch( pNodeNew->rule_id, RS43_3, pNodeNew );
		} catch( CMTException *e )
		{
			strcpy( errMessage, (char *) e->GetEMessage() );
			e->Delete();
			pNodeNew->loaded = 'X';
			return -1;
		}		
	}
	    
    return 0;
}


int CMRLoadData::LoadRuleReturn( RULE_LIST *pRulePtr )
{

EXEC SQL BEGIN DECLARE SECTION;
    short         RS47_2;
EXEC SQL END DECLARE SECTION;

// RULE Return Types
EXEC SQL DECLARE Cursor_ResTypes CURSOR FOR
         SELECT      RS47_2
         FROM        BRS470TB
         WHERE       RS43_1 = :RS43_1
         ORDER BY    RS47_1  ASC;

EXEC SQL DECLARE Cursor_ParmTypes CURSOR FOR
         SELECT      RS49_2
         FROM        BRS490TB
         WHERE       RS43_1 = :RS43_1
         ORDER BY    RS49_1  ASC;

    struct sqlca    sqlca;
    int     i;
    char    retTypes[200];    
    char    ParmTypes[200];

    RS43_1 = pRulePtr->rule_id;

    /*   Result Types   */
    EXEC SQL OPEN Cursor_ResTypes;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
              "LoadRuleReturn : Cursor_ResTypes Open (%d)",SQLCODE );
        return -1;
    }

       
    for( i=0;;i++) {
        EXEC SQL
             FETCH   Cursor_ResTypes
             INTO    :RS47_2;
        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf(m_errMessage,
                    "LoadRuleReturn : Cursor_ResTypes Fetch (%d)",
                    SQLCODE );
            EXEC SQL CLOSE Cursor_ResTypes;
            return -1;
        }

		retTypes[i] = (unsigned char) RS47_2;   
    }
    
    pRulePtr->retCnt = i;
/*    
if ( RS43_1 == 47 ) {
	for ( int x=0; x<i; x++ ) printf("%d : %d\n", x, retTypes[x] );
}
*/    
                       
    EXEC SQL CLOSE Cursor_ResTypes;

    pRulePtr->retType = ( char * ) pCMRGblVars->MetisAlloc ( i + 1 );
    
    memcpy( pRulePtr->retType, retTypes, i );

/*  Load Parameter  */
    EXEC SQL OPEN Cursor_ParmTypes;

    if ( SQLCODE != 0 ) {
        sprintf(m_errMessage,
            "LoadRuleReturn : Cursor_ParmTypes Open (%d)", SQLCODE );
        return -1;
    }

       
    for( i=0;;i++) {
        EXEC SQL
             FETCH   Cursor_ParmTypes
             INTO    :RS47_2;
        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf(m_errMessage,
         "LoadRuleReturn : Cursor_ParmTypes Fetch (%d)", SQLCODE );
            EXEC SQL CLOSE Cursor_ParmTypes;
            return -1;
        }

		ParmTypes[i] = (unsigned char) RS47_2;    
    }

    EXEC SQL CLOSE Cursor_ParmTypes;

	if ( i > 0 ) {
	   pRulePtr->parmType = 
		  (char*) pCMRGblVars->MetisAlloc ( i+1 );
    
       memcpy( pRulePtr->parmType, ParmTypes, i );
       pRulePtr->parmType[i] = 0;
    } else
	   pRulePtr->parmType = 0;

    return 0;
}


int CMRLoadData::LoadRuleBody( RULE_LIST *pRule )
{
EXEC SQL DECLARE Cursor_RuleVers CURSOR FOR
         SELECT     RS44_1, RS44_2, RS44_3, RS44_4
         FROM       BRS440TB
         WHERE		RS43_1 = :RS43_1
         ORDER BY   RS44_2  DESC;
	
    struct sqlca    sqlca;
    RULE_VERS	   *pVer;
    int				rc = -1;
	char			msg[200];
	
#ifdef _DEBUG
//    sprintf(msg, "LoadRuleBody : RuleId[%d]  Type[%d]", pRule->rule_id, pRule->r_type );       
//   _WriteLogNo( _LOG_LOG, msg ); 
#endif

	RS43_1 = pRule->rule_id;

	if ( pRule->r_type == 3 ) {  // BRANCH Rule일때는 Version이 없다
		pRule->pVers = (RULE_VERS *) pCMRGblVars->MetisAlloc( sizeof(RULE_VERS) );
		pVer = pRule->pVers;
		pVer->stDate[0] = 0;
		pVer->endDate[0] = 0;
		pVer->rule_data = 0;
		pVer->rows = 0;
		pVer->pNext = 0;
	
		rc = loadBranchRule( pRule );
	} else {
	
		EXEC SQL  OPEN  Cursor_RuleVers;

		ChkDBError( sqlca, "LoadRuleBody( Cursor Open )" );

		pVer = 0;
	
		while( 1 )
		{        
			EXEC SQL
				FETCH       Cursor_RuleVers
				INTO        :RS44_1, :RS44_2, :RS44_3, RS44_4;

			ChkDBError( sqlca, "Fetch Cursor_RuleVers" );
			if ( SQLCODE == NOTFOUND ) break;

			if ( ! pVer ) {
				pVer = (RULE_VERS *) pCMRGblVars->MetisAlloc( sizeof(RULE_VERS) );
				pRule->pVers = pVer;
			} else {
				pVer->pNext = (RULE_VERS *) pCMRGblVars->MetisAlloc( sizeof(RULE_VERS) );
				pVer = pVer->pNext;
			}

			strcpy( pVer->stDate, McRTrim(RS44_2) );
			strcpy( pVer->endDate, McRTrim(RS44_3) );
			pVer->rule_data = 0;
			pVer->rows = 0;
			pVer->pNext = 0;


			switch(pRule->r_type) {
			case 1 : /*   CONDITIONAL RULE  */
				rc = loadConditionalRule( pRule, pVer );
				break;
			case 2 : /*   DYNAMIC SQL RULE  */
				rc = loadDynaSqlRule( pRule, pVer );
			 break;
			case 4 : /*   External RULE  */
				rc = loadExternalRule( pRule );
				break;
			case 5 : /*   Table RULE  */
				rc = loadTableRule( pRule, pVer, (unsigned char) RS44_4 );
				break;
			case 6 : /*   Flow RULE  */
				rc = loadFlowRule( pRule, pVer );
				break;
			default : /* Garbage  */
				break;
			}
			
			if ( rc != 0 ) break;
		}
		
		 EXEC SQL CLOSE Cursor_RuleVers;
	}
	
	if ( rc == 0 ) pRule->loaded = 'Y';
	else {
		pRule->loaded = 'X';
		sprintf(msg, "Rule load error ( %d ).", pRule->rule_id );
		_WriteLogNo( _LOG_LOG, msg ); 
		_WriteLogNo( _LOG_LOG, m_errMessage ); 
    }
   
    return rc;
}

int CMRLoadData::loadConditionalRule( RULE_LIST *pRule, RULE_VERS *pVer )
{
// CRULE DATA
EXEC SQL DECLARE Cursor_Stmt CURSOR FOR
         SELECT     RS45_1, RS45_2
         FROM       BRS450TB
         WHERE      RS43_1 = :RS43_1 AND
					RS44_1 = :RS44_1
         ORDER BY   RS45_1  ASC;

    struct sqlca    sqlca;
    CRULE_DATA     *pCRule;
    int				nLine;

    CMRParser  Parsing;
    
    RS43_1 = pRule->rule_id;

    EXEC SQL  OPEN  Cursor_Stmt;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadConditionRule : Cursor Open. (%d)", SQLCODE );

//		free( pCRuleData );
        return -1;
    }

	nLine = 0;
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_Stmt
            INTO        :RS45_1, :RS45_2;

        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "loadConditionRule : Cursor Fetch. (%d)", SQLCODE );
            return -1;
        }
        
        nLine++;

        if ( ! pVer->rule_data ) {
            pCRule = (CRULE_DATA *)
				pCMRGblVars->MetisAlloc( sizeof(CRULE_DATA) );
            pVer->rule_data = pCRule;
        } else {
            pCRule->pNext = (CRULE_DATA *)
				pCMRGblVars->MetisAlloc( sizeof(CRULE_DATA));
            pCRule = pCRule->pNext;
        }

        pCRule->resGbn = 0;
		pCRule->cond = 0;
        pCRule->pNext = 0;
        
        rtrim(RS45_2);
        
        if ( (pCRule->result = Parsing.ParseResult( RS45_2 ))
              == (CRULE_STMT *) -1) {
			pCRule->result = 0;
			EXEC SQL CLOSE Cursor_Stmt;

            return -1;
        }

//******************************************************************
		if ( pCRule->result ) {
		
			int mode;
			VALUE_UNION *pResValue;
			pResValue = buildResultRec((CRULE_STMT*)pCRule->result, pRule, &mode);

			if ( mode < 0 ) {
				sprintf( m_errMessage,
					 "Result expression syntax error.  rule=%d  line=%d", pRule->rule_id, nLine );			
				return -1;
			}

			//  2차원Array 아직 처리못함
			if ( mode > 2 ) {
				sprintf( m_errMessage,
					 "Result expression syntax error.  rule=%d  line=%d", pRule->rule_id, nLine );			
				return -1;
			}
			
						
			if ( mode > 0 ) {
				CRULE_STMT *p, *q;
				int len;

				p = (CRULE_STMT *) pCRule->result;
				while ( p ) {
					q = p->pNext;
					if ( (q->tokType == TOKENTYPE_CONST_C ||
						  q->tokType == TOKENTYPE_CONST_L )
						  && q->uni.tokInfo ) {
						len = strlen((char*) q->uni.tokInfo);

						pCMRGblVars->MetisFree( q->uni.tokInfo, len );
					}

					q = p->pExpression;
					pCMRGblVars->MetisFree( p, sizeof(CRULE_STMT) );
					p = q;
				}

				pCRule->result = (void *) pResValue;

				pCRule->resGbn = mode;
			}
		}
//******************************************************************


		EXEC SQL
			SELECT	RS4A_2
			INTO   :RS4A_2
			FROM	BRS4A0TB
			WHERE	RS43_1 = :RS43_1 AND
					RS44_1 = :RS44_1 AND
					RS45_1 = :RS45_1 AND
					RS4A_1 = 1;

		if ( SQLCODE == 0 ) rtrim(RS4A_2);
        else if ( SQLCODE == NOTFOUND ) RS4A_2[0] = 0;
        else {
            sprintf( m_errMessage,
                 "loadConditionRule : Cursor Fetch. (%d)", SQLCODE );
            return -1;
        }
   
        if ( (pCRule->cond = Parsing.ParseExpression( RS4A_2 ))
              == (CRULE_STMT *) -1 ) {

			pCRule->cond = 0;
			EXEC SQL CLOSE Cursor_Stmt;

            return -1;
        }
    }   

    EXEC SQL CLOSE Cursor_Stmt;

//	if ( pCRuleData->UseIdx == bIndexUsed ) bIndexUsed = 0;

	return 0;
}


int CMRLoadData::loadDynaSqlRule(RULE_LIST *pRule, RULE_VERS *pVer )
{
EXEC SQL BEGIN DECLARE SECTION;
    char         RS46_1[31];
    short        RS46_2;
    short		 RS46_3;
    VARCHAR      RS4E_2[3001];
EXEC SQL END DECLARE SECTION;
EXEC SQL DECLARE Cursor_QryStmt CURSOR FOR
         SELECT     RS4E_2
         FROM       BRS4E0TB
         WHERE      RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1
         ORDER BY   RS4E_1  ASC;
         
    struct sqlca    sqlca;
    QRULE_DATA		*pQRule;
    
#ifdef _KDB40
    char			sQry[15000];
#else
    char			sQry[10000];
#endif		
    
    RS43_1 = pRule->rule_id;

    EXEC SQL
        SELECT    RS46_1, RS46_2, RS46_3
          INTO   :RS46_1, :RS46_2, :RS46_3
          FROM    BRS460TB
        WHERE     RS43_1 = :RS43_1 AND
                  RS44_1 = :RS44_1;

    if ( SQLCODE != 0 ) {
        sprintf(m_errMessage,
			    "loadDynaSqlRule( %d ) : Select. (%d)\n",
                RS43_1, SQLCODE );
        return -1;
    }

                
    pQRule = (QRULE_DATA *)
		pCMRGblVars->MetisAlloc( sizeof(QRULE_DATA));
        
    strcpy( pQRule->DBName, rtrim(RS46_1) );
    pQRule->MaxRows = RS46_2;
    pQRule->QueryStatement = 0;
    pQRule->pBindValue = 0;
    
    pRule->s_type = (unsigned char) RS46_3;
    
    
    EXEC SQL  OPEN  Cursor_QryStmt;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadDynaSqlRule : Cursor Open. (%d)", SQLCODE );
        return -1;
    }

//printf("HERE=====\n");
	int pos = 0;
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_QryStmt
            INTO        :RS4E_2;

        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "loadDynaSqlRule : Cursor Fetch. (%d)", SQLCODE );
            return -1;
        }
        
//printf("LENG = %d\n", RS4E_2.len );
		
		memcpy( sQry+pos, RS4E_2.arr, RS4E_2.len );
		pos += RS4E_2.len;
	}
	
	sQry[pos] = 0;
	
	
	EXEC SQL CLOSE Cursor_QryStmt;
	
	if ( strlen(sQry) < 10 ) {
		sprintf(m_errMessage, "  Query statement not defined.   rule=%d", RS43_1 );
		return -1;	
	}
	
	ParseQueryRule( pQRule, sQry );

    pVer->rule_data = pQRule;
    
    return 0;    
}


int CMRLoadData::loadBranchRule( RULE_LIST *pRule )
{
EXEC SQL BEGIN DECLARE SECTION;
	char RS4C_1[201];
	char RS4C_2[201];
EXEC SQL END DECLARE SECTION;

    struct sqlca    sqlca;
    BRULE_DATA     *pBRule;

    RS43_1 = pRule->rule_id;

    EXEC SQL
        SELECT    RS4C_1, RS4C_2
		INTO     :RS4C_1, :RS4C_2
        FROM      BRS4C0TB
        WHERE     RS43_1 = :RS43_1;

    if ( SQLCODE != 0 ) {
        sprintf(m_errMessage, "loadBranchRule : Select. (%d) : %s\n",
                SQLCODE, SQLMESSAGE );
        return -1;
    }

	rtrim(RS4C_1);   rtrim(RS4C_2);

    pBRule = (BRULE_DATA *)
		pCMRGblVars->MetisAlloc( sizeof(BRULE_DATA) );

    pBRule->BranchSubString = ParseBranchRule( RS4C_1 );

    pBRule->resGbn = 0;
    pBRule->result = 0;
	
	if ( RS4C_2[0] ) {
        int gbn;
		pBRule->result = buildDefaultResult( RS4C_2, pRule, & gbn );
		//  0:Rule,Item포함  1:상수Only  2:Array  -1:Error		
		if ( gbn < 0 ) {
			sprintf(m_errMessage, "  Branch default result syntax error.   rule=%d", RS43_1 );
			return -1;
		}
		
		
		//  2차원Array 아직 처리못함
		if ( gbn > 2 ) {
			sprintf(m_errMessage, "  Branch default result syntax error.   rule=%d", RS43_1 );		
			return -1;
		}
					
        pBRule->resGbn = (char) gbn;
	}

    pRule->pVers->rule_data = pBRule;

    return 0;
}


int CMRLoadData::loadTableRule( RULE_LIST *pRule, RULE_VERS *pVer, unsigned char bSorted )
{
EXEC SQL BEGIN DECLARE SECTION;
    char         RS4B_2[201];
    short        RS4B_3;
    short        RS4B_4;
	short        RS4B_5;
	short        RS4B_6;
	short        RS4B_7;
	_SQLINT      ColCnt;
	_SQLINT      RowCnt;	
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE Cursor_RS4B CURSOR FOR
         SELECT     RS4B_2, RS4B_3, RS4B_4, RS4B_5, RS4B_6, RS4B_7
         FROM       BRS4B0TB
         WHERE      RS43_1 = :RS43_1 AND
		            RS44_1 = :RS44_1
         ORDER BY   RS4B_1  ASC;

    struct sqlca    sqlca;
	TRULE_DATA     *pTRule;
	int i = 0;

    RS43_1 = pRule->rule_id;

	EXEC SQL
         SELECT     COUNT(*)
		 INTO		:ColCnt
         FROM       BRS4B0TB
         WHERE      RS43_1 = :RS43_1 AND
		            RS44_1 = :RS44_1;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadTableRule : Select Column Count. (%d)",SQLCODE );
        return -1;
    }


    pTRule = (TRULE_DATA *)	pCMRGblVars->MetisAlloc( sizeof(TRULE_DATA) );
    
    pTRule->sorted = bSorted;
	pTRule->cond1 = 0;
	pTRule->resGbn = 0;
	pTRule->result = 0;
	pTRule->iCnt = 0;
	
	pVer->rule_data = pTRule;


	EXEC SQL
         SELECT     COUNT(*)
		 INTO		:RowCnt
         FROM       BRS450TB
         WHERE      RS43_1 = :RS43_1 AND
		            RS44_1 = :RS44_1;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadTableRule : Select Date Row Count. (%d)",SQLCODE);
        return -1;
    }

	if ( RowCnt == 0 ) return 0;

	pVer->rows = (short) RowCnt;

	pTRule->iCnt = (short) ColCnt;

	if ( ColCnt > 0 ) {
		pTRule->cond1 = (TRULE_COL*) pCMRGblVars->MetisAlloc( sizeof(TRULE_COL) * ColCnt );

		for (i=0; i<pTRule->iCnt; i++) {
			pTRule->cond1[i].vMin = 0;
			pTRule->cond1[i].vMax = 0;
		}
   	
   	
		EXEC SQL  OPEN  Cursor_RS4B;
		
		if ( SQLCODE != 0 ) {
		    sprintf( m_errMessage,
		            "loadTableRule : Cursor Open. (%d)", SQLCODE );
		    return -1;
		}
   	
		i = 0;
		while( 1 )
		{
			EXEC SQL
					FETCH  Cursor_RS4B
					INTO  :RS4B_2, :RS4B_3, :RS4B_4, :RS4B_5, :RS4B_6, :RS4B_7;
		
			if ( SQLCODE == NOTFOUND ) break;
		    
			if ( SQLCODE != 0 ) {
				sprintf( m_errMessage,
		             "loadTableRule : Cursor Fetch. (%d)", SQLCODE );
				return -1;
			}
		
			//printf("%d %d type(%d) %d %d %d\n", RS4B_2, RS4B_3, RS4B_4, RS4B_5, RS4B_6, RS4B_7 );
		
			//  Setting COLUMN INFO
			 
			rtrim(RS4B_2);
			 						
			if ( RS4B_3 == TR_COL_TP_GBLV ) {
				pTRule->cond1[i].id = 0;
				strcpy( pTRule->cond1[i].vName, RS4B_2 );
			} else {
				pTRule->cond1[i].id    = atoi(RS4B_2);
				pTRule->cond1[i].vName[0] = 0;
			}
			
			pTRule->cond1[i].gbn   = RS4B_3;
			pTRule->cond1[i].pType = RS4B_4;
			pTRule->cond1[i].idx   = RS4B_5;
			pTRule->cond1[i].rSeq  = RS4B_6;
			pTRule->cond1[i].range = RS4B_7;
			
			if ( RS4B_4 == TR_IN_TP_OPTR ) {		//  연산자형
				pTRule->cond1[i].vMin = (TRULE_OPTR **)
					pCMRGblVars->MetisAlloc(sizeof(TRULE_OPTR*) * pVer->rows);
			} else if ( RS4B_4 == TR_IN_TP_COND ) {	//  조건형
				pTRule->cond1[i].vMin = (CRULE_STMT **)
					pCMRGblVars->MetisAlloc(sizeof(CRULE_STMT*) * pVer->rows);	
			} else {					//  상수, 범위형
				pTRule->cond1[i].vMin  = (VALUE_UNION*)
					pCMRGblVars->MetisAlloc(sizeof(VALUE_UNION) * pVer->rows);
			
				if ( RS4B_4 == 1 ) {
					pTRule->cond1[i].vMax = (VALUE_UNION*)
						pCMRGblVars->MetisAlloc(sizeof(VALUE_UNION) * pVer->rows);
				}
			}
			
			i++;
		}   
		
		EXEC SQL CLOSE Cursor_RS4B;
	}


/*  result 생성  */
	pTRule->resGbn =
		(unsigned char *) pCMRGblVars->MetisAlloc(pVer->rows);

	pTRule->result = (VALUE_UNION **)
		pCMRGblVars->MetisAlloc(sizeof(RESULT_REC *) * pVer->rows);

	int rc = loadTableRuleResData( pRule, pTRule );
	if ( rc != 0 ) {
		pCMRGblVars->MetisFree( pTRule, sizeof(TRULE_DATA) );
		pVer->rule_data = 0;
		return rc;
	}


/*  col data 생성  */
	if ( ColCnt > 0 ) {
		rc = loadTableRuleColData( pTRule );
		if ( rc != 0 ) {
			pCMRGblVars->MetisFree( pTRule, sizeof(TRULE_DATA) );
			pVer->rule_data = 0;
			return rc;
		}
	}
	
	return 0;
}


int CMRLoadData::loadTableRuleResData( RULE_LIST *pRule, TRULE_DATA *pTR )
{
EXEC SQL DECLARE Cursor_TRule CURSOR FOR
         SELECT     RS45_1, RS45_2
         FROM       BRS450TB
         WHERE      RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1
         ORDER BY   RS45_1  ASC;

    struct sqlca    sqlca;
	int             i, rc=0;

    EXEC SQL  OPEN  Cursor_TRule;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadConditionRule : Cursor Open. (%d)", SQLCODE );
        return -1;
    }
	
	i = 0;
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_TRule
            INTO        :RS45_1, :RS45_2;

        if ( SQLCODE == NOTFOUND ) break;
        if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "loadTableRule : Cursor Fetch. (%d)", SQLCODE );
            rc = -1;
            break;
        }
        
        rtrim(RS45_2);

//printf("loadTableRuleData [%s]\n", RS45_2 );

		//  Build Result
		if ((pTR->result[i]	= buildTRuleResultRec(pRule, RS45_2))
				== (VALUE_UNION*) -1 ){
			rc = -1;
			break;
		}


		//  2차원Array 아직 처리못함
		if ( RS45_2[0] > 2 ) {
		    sprintf( m_errMessage, "Not applied Two-dimensional array" );
			rc = -1;
			break;
		}

		pTR->resGbn[i] = RS45_2[0];
			
		i++;
    }

    EXEC SQL CLOSE Cursor_TRule;
	
	return rc;
}


int CMRLoadData::loadTableRuleColData( TRULE_DATA *pTR )
{
EXEC SQL DECLARE Cursor_TRuleColData CURSOR FOR
         SELECT     RS45_1, RS4A_1, RS4A_2, RS4A_3
         FROM       BRS4A0TB
         WHERE      RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1
         ORDER BY   RS45_1, RS4A_1 ASC;

	struct sqlca	sqlca;
	VALUE_UNION		*p;
	CRULE_STMT		**q;
	TRULE_OPTR		**t;
	TRULE_COL		*pTRCol;
	short			optr;
	int				row;
	int				rc=0;  

	EXEC SQL  OPEN  Cursor_TRuleColData;

	if ( SQLCODE != 0 ) {
		sprintf( m_errMessage,
                "loadTableRuleColData : Cursor Open. (%d)", SQLCODE );
		return -1;
	}

//printf("RS43_1 [%d]  RS44_1 [%f]\n", RS43_1, RS44_1 );		

	while( 1 )
	{
		EXEC SQL
            FETCH       Cursor_TRuleColData
            INTO        :RS45_1, :RS4A_1, :RS4A_2, :RS4A_3;

		if ( SQLCODE == NOTFOUND ) break;
        
		if ( SQLCODE != 0 ) {
			sprintf( m_errMessage, "loadTableRuleColData : Cursor Fetch. (%d)", SQLCODE );
			rc = -1;
			break;
		}

		rtrim(RS4A_2);    rtrim(RS4A_3);

		pTRCol = & pTR->cond1[RS4A_1 - 1];
		row = RS45_1 - 1;
        
//printf("loadTableRuleColData : type[%d] row[%d] seq[%d] [%s] [%s]\n", pTRCol->pType, RS45_1, RS4A_1, RS4A_2, RS4A_3 );
		
		switch ( pTRCol->pType ) {
		case TR_IN_TP_CONST :		//  상수
		case TR_IN_TP_RANGE :		//  범위형
		case TR_IN_TP_RONLY :		//  ReadOnly(상수)
			p = (VALUE_UNION*) pTRCol->vMin;
			strcpy( p[row].strVal, RS4A_2 );

			if ( pTRCol->pType == TR_IN_TP_RANGE ) {  //  범위형이면 vMax Set
				p = (VALUE_UNION*) pTRCol->vMax;
				strcpy( p[row].strVal, RS4A_3 );
			}
			break;

		case TR_IN_TP_OPTR :		//  연산자형		
			t = (TRULE_OPTR **) pTRCol->vMin;
			
			optr = atoi( RS4A_2 );
			
			if ( optr == 0 ) {
				t[row] = 0;
			} else {		
				t[row] = (TRULE_OPTR *) pCMRGblVars->MetisAlloc(sizeof(TRULE_OPTR));
				
				t[row]->optr = optr;
			
				if ( parseTRuleValue( RS4A_3, t[row], optr ) != 0 ) {
					rc = -1;
					break;
				}
			}
			break;
			
		case TR_IN_TP_COND :		//  조건형
			q = (CRULE_STMT **) pTRCol->vMin;
					
			if ( RS4A_2[0] == 0 ) {
				q[row] = 0;
			} else {
				CMRParser  Parsing;
				if ( (q[row] = Parsing.ParseExpression( RS4A_2 )) == (CRULE_STMT *) -1 ) {
					q[row] = 0;
					rc = -1;
					break;
				}
			}
			break;
			
		default : 
			rc = -1;
		}			
	}

//printf("loadTableRuleColData end\n");
	EXEC SQL CLOSE Cursor_TRuleColData;

	return rc;
}


int  CMRLoadData::parseTRuleValue(char *str, TRULE_OPTR *v, short optr)
{
#ifdef _KDB40
	char  s[50][31];
#else
	char  s[50][51];
#endif		

	char  buf[500];
	char *p;
	short n=0, i;
	
	if ( v->optr == 0 ) {
		v->cnt = 0;
		v->sVal = 0;
		return 0;
	}
	
	p = str;
	while ( *p ) {
		while ( *p ) {
			if ( isgraph( *p ) ) break;
			p++;
		}

		if ( ! *p ) break;

		i = 0;
		while ( *p ) {
			if ( *p == ',' ) {
				p++;
				break;
			}

			buf[i++] = *p++;
		}
		
		if ( i > 0 ) {
#ifdef _KDB40
			buf[i] = 0;   buf[30] = 0;
#else
			buf[i] = 0;   buf[50] = 0;
#endif		
			McRTrim( buf );
			strcpy( s[n], buf );
			n++;
		}
		
		if ( n == 50 ) break;
	}


/*	
#ifdef _DEBUG
for ( i=0; i<n; i++ ) printf("parseTRuleValue [%s]\n", s[i] );
#endif
*/
	
	if ( optr < 7 ) {
		if ( n != 1 ) return -1;
	} else if ( optr < 9 ) {
		if ( n != 2 ) return -1;
	} else {
		if ( n == 0 ) return -1;
	}
			
	v->cnt = n;
	v->sVal = (char **) pCMRGblVars->MetisAlloc(sizeof(char*) * n);
	
	for ( i=0; i<n; i++ ) {
		v->sVal[i] = (char *) pCMRGblVars->MetisAlloc( strlen(s[i]) + 1 );
		strcpy( v->sVal[i], s[i] );
	}

	return 0;
}


//  현재 비사용
/*
void  CMRLoadData::setColData(char *str, unsigned char dType, VALUE_UNION *v)
{

	switch ( dType ) {
		case DATA_TYPE_STRING :
				strcpy( v->strVal,str );	break;
		case DATA_TYPE_DOUBLE :
				v->dblVal = atof( str );	break;
		case DATA_TYPE_LONG :
				v->longVal = atoi( str );	break;
		default :
				break;
	}
}
*/


int CMRLoadData::loadFlowRule( RULE_LIST *pRule, RULE_VERS *pVer )
{
// FRULE DATA
EXEC SQL DECLARE Cursor_Flow CURSOR FOR
         SELECT     RS48_1, RS48_2, RS48_3
         FROM       BRS480TB
         WHERE      RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1
         ORDER BY   RS48_1  ASC;

    struct sqlca    sqlca;
    FRULE_DATA     *pFRuleData;
    CRULE_STMT	   *pStmt;
    int             idx = 0;

    CMRParser  Parsing;


	RS43_1 = pRule->rule_id;
	
	EXEC SQL SELECT COUNT(*)
			 INTO   :RS48_1
			 FROM   BRS480TB
			 WHERE  RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1;
                    
	if ( RS48_1 == 0 ) {
		pVer->rule_data = 0;
		return 0;
	}

	pVer->rows = (short) RS48_1;
	
	pFRuleData = (FRULE_DATA *)
		pCMRGblVars->MetisAlloc( sizeof(FRULE_DATA) * RS48_1);

	pVer->rule_data = pFRuleData;


    EXEC SQL  OPEN  Cursor_Flow;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadFlowRule : Cursor Open. (%d)", SQLCODE );
        return -1;
    }

    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_Flow
            INTO        :RS48_1, :RS48_2, :RS48_3;

        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "loadFlowRule : Cursor Fetch. (%d)", SQLCODE );
            return -1;
        }

//      Start Node 제외
//		if ( RS48_1 == 0 ) continue;
		
        pFRuleData[idx].pType = RS48_2;
        pFRuleData[idx].dGbn = 0;
        pFRuleData[idx].exp = 0;
        pFRuleData[idx].sw = 0;

        rtrim(RS48_3);
        
        if ( RS48_2 == 2 || RS48_2 == 5) { // IF, CASE문
			if ( (pStmt = Parsing.ParseExpression( RS48_3 ))
				== (CRULE_STMT *) -1 ) {
				EXEC SQL CLOSE Cursor_Flow;
				return -1;
			}
			
			pFRuleData[idx].exp = pStmt;
        } else {
			if ( (pStmt = Parsing.ParseResult( RS48_3 ))
				  == (CRULE_STMT *) -1) {
				EXEC SQL CLOSE Cursor_Flow;
				return -1;
			}

			pFRuleData[idx].exp = pStmt;

			if ( RS48_2 == 4 && pStmt ) {  //  반환일때
				int		mode;
				VALUE_UNION *pResValue = buildResultRec(pStmt, pRule, &mode);
				
				if ( mode < 0 ) {
					sprintf( m_errMessage,
						 "  Result expression syntax error.  rule=%d  nodeExp=%s", pRule->rule_id, RS48_3 );
						 
					pFRuleData[idx].exp = 0;
					EXEC SQL CLOSE Cursor_Flow;
					 		
					return -1;
				}

				//  2차원Array 아직 처리못함
				if ( mode > 1 ) {
					sprintf(m_errMessage, "  Result expression syntax error.  rule=%d  nodeExp=%s", pRule->rule_id, RS48_3 );
					pFRuleData[idx].exp = 0;
					EXEC SQL CLOSE Cursor_Flow;					
					return -1;
				}

				if ( mode == 1 ) {   //  상수일때만
					CRULE_STMT *p, *q;
					int len;

					p = (CRULE_STMT *) pStmt;
					while ( p ) {
						q = p->pNext;
						if ( (q->tokType == TOKENTYPE_CONST_C ||
							  q->tokType == TOKENTYPE_CONST_L )
							  && q->uni.tokInfo ) {
							len = strlen((char*) q->uni.tokInfo);

							pCMRGblVars->MetisFree( q->uni.tokInfo, len );
						}

						q = p->pExpression;
						pCMRGblVars->MetisFree( p, sizeof(CRULE_STMT) );
						p = q;
					}

					pFRuleData[idx].exp = (void *) pResValue;

					pFRuleData[idx].dGbn = 1;
				}
			}
		}

		if ( loadFlowRuleSw( &pFRuleData[idx] ) != 0 ) break;

		idx++;
    }   

    EXEC SQL CLOSE Cursor_Flow;

	return 0;
}


int CMRLoadData::loadFlowRuleSw( FRULE_DATA *pFR )
{
// FRULE DATA SWITCH
EXEC SQL DECLARE Cursor_FlowSw CURSOR FOR
         SELECT     RS4D_2, RS4D_3
         FROM       BRS4D0TB
         WHERE      RS43_1 = :RS43_1 AND
                    RS44_1 = :RS44_1 AND
                    RS48_1 = :RS48_1
         ORDER BY   RS4D_1  ASC;

    struct sqlca    sqlca;
	FRULE_DATA_SW *pLast=0;

    EXEC SQL  OPEN  Cursor_FlowSw;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadFlowRuleSw : Cursor Open. (%d)", SQLCODE );
        return -1;
    }
	
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_FlowSw
            INTO        :RS4D_2, :RS4D_3;

        if ( SQLCODE == NOTFOUND ) break;
        else if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "loadFlowRuleSw : Cursor Fetch. (%d)", SQLCODE );
            return -1;
        }

		if ( ! pLast ) {
			pFR->sw = pLast = (FRULE_DATA_SW*) pCMRGblVars->MetisAlloc( sizeof(FRULE_DATA_SW) );
		} else {
			pLast->pNext = (FRULE_DATA_SW*) pCMRGblVars->MetisAlloc( sizeof(FRULE_DATA_SW) );
			pLast = pLast->pNext;
		}

		//  Link < 0이면 0으로 변경.   룰을 종료해야 하는가...		
		pLast->Link = RS4D_2;
		strcpy( pLast->caseExp, rtrim(RS4D_3) );
		pLast->pNext = 0;
    }   

    EXEC SQL CLOSE Cursor_FlowSw;

	return 0;
}


int CMRLoadData::loadExternalRule( RULE_LIST *pRule )
{
    return 0;
}


/****************************************************************/

extern  DATABASE_LIST *pDBList;

void   CMRLoadData::BuildDataBaseStruct( void )
{
EXEC SQL BEGIN DECLARE SECTION;
    char         RS12_1[31];         // DB Name
    short        RS12_2;             // DBMS
    char         RS12_3[31];         // DB User
#ifdef _KDB40
    char         RS12_4[31];         // DB Passwd
#else
    char         RS12_4[201];         // DB Passwd
#endif		
    short        RS12_5;             // Agents
    char         RS12_6[31];         // DB Physical Name
EXEC SQL END DECLARE SECTION;

// DATABASE LIST
EXEC SQL DECLARE Cursor_DataBase CURSOR FOR
         SELECT     RS12_1, RS12_2, RS12_3, RS12_4, RS12_5, RS12_6
         FROM       BRS120TB;

    struct sqlca    sqlca;

    DATABASE_LIST      *pDBPtr;

    pDBList = 0;
    
    EXEC SQL  OPEN  Cursor_DataBase;

    ChkDBError( sqlca, "BuildDataBaseStruct( Cursor Open )" );

    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_DataBase
            INTO        :RS12_1, :RS12_2, :RS12_3, :RS12_4, :RS12_5, :RS12_6;

        ChkDBError( sqlca, "Fetch Cursor_DataBase" );
        if ( SQLCODE == NOTFOUND ) break;

        if ( ! pDBList ) {
            pDBPtr = (DATABASE_LIST *)
				pCMRGblVars->MetisAlloc( sizeof(DATABASE_LIST));
            pDBList = pDBPtr;
        } else {
            pDBPtr->pNext = (DATABASE_LIST *)
				 pCMRGblVars->MetisAlloc( sizeof(DATABASE_LIST) );
            pDBPtr = pDBPtr->pNext;
        }
        
        strcpy( pDBPtr->DBName, rtrim(RS12_1) );
        pDBPtr->dbms = RS12_2;
        strcpy( pDBPtr->DBPName, rtrim(RS12_6) );
        strcpy( pDBPtr->DBUser, rtrim(RS12_3) );
 
		if(_DBPWD_ENC[0]=='Y'||_DBPWD_ENC[0]=='y'){
				DecodeString(rtrim(RS12_4) , pDBPtr->DBPasswd);
		}else{
		    strcpy( pDBPtr->DBPasswd, rtrim(RS12_4) );
		}
		//해당 컬럼에 문자가 아닌 쓰레기 값이 들어가는 경우 발생 0xb 하여 추가 2017.06.02  ad2001 
		for( int x=0; x < strlen(pDBPtr->DBPasswd); x++){
			if( pDBPtr->DBPasswd[x]>=0x00 && pDBPtr->DBPasswd[x]<=0x1f){
				pDBPtr->DBPasswd[x]=0x00;
			}
		}
        pDBPtr->agents = RS12_5;
        pDBPtr->pAgtMgr = 0;
        pDBPtr->pNext = 0;
    }   

    EXEC SQL CLOSE Cursor_DataBase;
}


/****************************************************************/
long CMRDataList::DispItems( char *PgmId, long cd, char *msg )
{
	long rc;
	char lmsg[128];

	m_sect.Lock();

	rc = 0;

	rc=ConnectLoadDatabase( lmsg );

	if ( rc != 0 ) {
		strcpy( msg, lmsg );
	} else {
		rc = DispItemsProc( PgmId, cd, msg );
		DisConnectLoadDatabase();
	}

	m_sect.Unlock();

	return rc;
}

long CMRDataList::DispItemsProc( char *PgmId, long cd, char *msg )
{
    EXEC SQL    BEGIN DECLARE SECTION;
		 char     RS91_1[27];
		 char     RS91_2[21];
		 _SQLINT  RS91_3;
		 char     RS91_4[501];
		 short    RS91_5;
		 short    RS91_6;
		 short    RS91_7;
		 short    RS91_8;
		 short    RS91_9;
		 
		 _SQLINT  RS92_1;
		 short    RS92_2;
#ifdef _KDB40
		 char     RS92_3[31];
#else
		 char     RS92_3[51];
#endif	
    EXEC SQL    END DECLARE SECTION;

    struct sqlca sqlca;

	long   rc = 0;

	strcpy( RS91_2, PgmId );
	RS91_3 = cd;
	if ( msg[0] == 0 )
	   strcpy( RS91_4, " " );
	else {
	   strncpy( RS91_4, msg, 500 );
	   RS91_4[500] = 0;
	}
	
// printf("1 : %s\n", PgmId );

#ifdef _DB2
	EXEC SQL SELECT COUNT(*), TO_CHAR(CURRENT TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF3')
		      INTO  :RS92_1, :RS91_1
		      FROM  BRS010TB
		      WHERE  RS01_1 = 1;
#endif

#ifdef _ORACLE		      
	EXEC SQL SELECT COUNT(*), TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF3')
		      INTO  :RS92_1, :RS91_1
		      FROM  DUAL;
#endif	

	McRTrim( RS91_1 );
//printf("2 : %d [%s]\n", RS92_1, RS91_1 );

	if( SQLCODE != 0 ) return SQLCODE;


	struct tm *newtime;
	time_t long_time;

	time( &long_time );				   /* Get time as long integer. */
	newtime = localtime( &long_time ); /* Convert to local time. */
	
	RS91_5 = newtime->tm_year+1900;
	RS91_6 = newtime->tm_mon+1;
	RS91_7 = newtime->tm_mday;
	RS91_8 = newtime->tm_wday;
	RS91_9 = newtime->tm_hour;


	EXEC SQL INSERT INTO BRS910TB
		       ( RS91_1,RS91_2,RS91_3,RS91_4,RS91_5,RS91_6,RS91_7,RS91_8,RS91_9 )
		     VALUES
			   ( :RS91_1,:RS91_2,:RS91_3,:RS91_4,:RS91_5,:RS91_6,:RS91_7,:RS91_8,:RS91_9 );
//printf("BRS910TB : %d %s\n", SQLCODE, SQLMESSAGE );
	if( SQLCODE != 0 ) return SQLCODE;


	if ( ! m_bValidItems ) return 0;
	

	for ( int i=0; i<m_itemCnt; i++ ) {
		for ( int j=0; j<m_itemValue[i].itemOcc; j++ ) {
			switch ( m_itemValue[i].itemType ) {
	    		case DATA_TYPE_LONG :
	                 sprintf(RS92_3,"%-ld",m_itemValue[i].mValue[j].longVal );
					 break;
	    		case DATA_TYPE_STRING :
	                 strcpy(RS92_3,m_itemValue[i].mValue[j].strVal );
					 break;
	    		case DATA_TYPE_DOUBLE :
	                 sprintf(RS92_3,"%-lf",m_itemValue[i].mValue[j].dblVal );
					 break;
		    	case DATA_TYPE_LSTRING :
#ifdef _KDB40
	                 strncpy(RS92_3,m_itemValue[i].mValue[j].pLStr, 30 );
					 RS92_3[30] = 0;
#else
	                 strncpy(RS92_3,m_itemValue[i].mValue[j].pLStr, 50 );
					 RS92_3[50] = 0;
#endif	
		             break;
			}

			if ( RS92_3[0] == 0 ) strcpy( RS92_3, " " );

			RS92_1 = (short) m_itemValue[i].itemCode;
			RS92_2 = j + 1;

			EXEC SQL INSERT INTO BRS920TB
				( RS91_1,RS92_1,RS92_2,RS92_3 )
				VALUES
				( :RS91_1,:RS92_1,:RS92_2,:RS92_3 );

			if( SQLCODE != 0 ) return SQLCODE;
		}
	}

	EXEC SQL COMMIT;

	return 0;
}


/********************************************************************/

void   CMRLoadData::BuildConfiguration( void )
{
    EXEC SQL    BEGIN DECLARE SECTION;
		_SQLINT		 RS16_1;    
		char		 RS16_3[201];
		short		 RS16_5;
    EXEC SQL    END DECLARE SECTION;

	EXEC SQL DECLARE Cursor_Env CURSOR FOR
			 SELECT RS16_1, RS16_3, RS16_5
		     FROM   BRS160TB
		     WHERE  RS16_1 >= 10000 AND
			        RS16_1 <= 19999
			 ORDER BY RS16_1;
    struct sqlca sqlca;
    
    ReadEngineConfig();
   
    
    EXEC SQL  OPEN  Cursor_Env;

    if ( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "loadEnveronment : Cursor Open. (%d)", SQLCODE );
        throw new CMTException( UERR_DBERROR, m_errMessage );
    }

    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_Env
			INTO        :RS16_1, :RS16_3, :RS16_5;

        if ( SQLCODE == NOTFOUND ) break;
        
		if ( SQLCODE != 0 ) {
            sprintf( m_errMessage,
                 "BuildConfiguration : Cursor Fetch. (%d)", SQLCODE );
            throw new CMTException( UERR_DBERROR, m_errMessage );
        }
        
        rtrim(RS16_3);

//printf("    %d [%s]\n", RS16_1, RS16_3 );

		switch ( RS16_1 ) {
		   case 10000 : //   Product Name
						strcpy( configRec.lpszProdName, RS16_3 );
						break;
		   case 10001 : //   Thread count per Engine
						configRec.ulNoThread = atoi( RS16_3 );
						if ( configRec.ulNoThread < 1 ) configRec.ulNoThread = 1;
						if ( configRec.ulNoThread > 50 ) configRec.ulNoThread = 50;
						break;
		   case 10002 : //   Max Listening Queue
						configRec.ulNoMaxQueueing = atoi( RS16_3 );
						if ( configRec.ulNoMaxQueueing < 10 ) configRec.ulNoMaxQueueing = 10;
						if ( configRec.ulNoMaxQueueing > 500 ) configRec.ulNoMaxQueueing = 500;						
						break;
		   case 10003 : //   Sleep Time
						configRec.ulSlTm = atoi( RS16_3 );
						if ( configRec.ulSlTm <= 0 ) configRec.ulSlTm = 0;
						else if ( configRec.ulSlTm < 5000 ) configRec.ulSlTm = 5000;
						else if ( configRec.ulSlTm > 20000 ) configRec.ulSlTm = 20000;
						break;
		   case 10004 : //   Keep connection
						configRec.ulKeepFlag = atoi( RS16_3 );
						break;						
		   case 10005 : //   Parm Size
						configRec.ulMaxParmSize = atoi( RS16_3 );
						if ( configRec.ulMaxParmSize < 1024 ) configRec.ulMaxParmSize = 1024;
						else if ( configRec.ulMaxParmSize > 300000 ) configRec.ulDiagIntv = 300000;
						break;
		   case 10006 : //   Diagnose Interval
						configRec.ulDiagIntv = atoi( RS16_3 );
						
						if ( configRec.ulDiagIntv <= 0 ) configRec.ulDiagIntv = 0;
						else if ( configRec.ulDiagIntv < 5 ) configRec.ulDiagIntv = 5;
						else if ( configRec.ulDiagIntv > 120 ) configRec.ulDiagIntv = 120;
						break;						
		   case 10010 : //   Log Path
						strcpy( configRec.lpszLogPath, RS16_3 );						
						if ( configRec.lpszLogPath[0] == 0 ) strcpy(configRec.lpszLogPath,".");
						break;
		   case 10011 : //   Trace Path
						strcpy( configRec.lpszTrcPath, RS16_3 );						
						if ( configRec.lpszTrcPath[0] == 0 ) strcpy(configRec.lpszTrcPath,".");
						break;
		   case 10012 : //   Log Queue Size
						configRec.ulLogQueueSz = atoi( RS16_3 );
						
						if ( configRec.ulLogQueueSz < 500 ) configRec.ulLogQueueSz = 500;
						if ( configRec.ulLogQueueSz > 5000 ) configRec.ulLogQueueSz = 5000;						
						break;
		   case 10013 : //   Disp Elapse Time
						configRec.usDispTm = atoi( RS16_3 );
						break;
		   case 10014 : //   Preload
						configRec.PreLoad[0] = RS16_3[0];
						break;	
		   case 10015 : //   Max Fetch Count
						configRec.ulMaxQueryCount = atoi( RS16_3 );
						break;
		   case 10016 : //   Run Timeout
						configRec.ulRunTimeOut = atoi( RS16_3 );
						break;
		   case 10017 : //   Thread Buffer Size
						configRec.ulMaxMemSize1 = atoi( RS16_3 ) * 1024;
						break;																																					
		   case 10018 : //   Thread Temp Buffer 1
						configRec.ulMaxMemSize2 = atoi( RS16_3 ) * 1024;
						break;																																					
		   case 10019 : //   Thread Temp Buffer 2
						configRec.ulMaxMemSize3 = atoi( RS16_3 ) * 1024;
						break;
		   case 10020 : //   Trace Always
						configRec.usTrace = atoi( RS16_3 );
						break;
		   case 10021 : //   Trace Always
						configRec.usAllTracle = atoi( RS16_3 );
						break;
		   case 10022 : //   us Rule Apply Time 
						configRec.usRuleApplyTime =atoi( RS16_3 );
						break;						
		   default    :
						break;
		}
    }
    
    EXEC SQL CLOSE Cursor_Env;

}


//  Engine 정보
void   CMRLoadData::ReadEngineConfig( void )
{
    EXEC SQL    BEGIN DECLARE SECTION;
    	_SQLINT		 RS17_1;
		char		 RS17_3[21];
		_SQLINT		 RS17_4;		
		_SQLINT		 RS17_5;
    EXEC SQL    END DECLARE SECTION;

    struct sqlca sqlca;
    
    RS17_1 = configRec.ulNoServer;

	EXEC SQL SELECT RS17_3, RS17_4, RS17_5
			 INTO  :RS17_3, :RS17_4, :RS17_5
		     FROM   BRS170TB
		     WHERE  RS17_1 = :RS17_1;

	if( SQLCODE != 0 ) {
        sprintf( m_errMessage,
                "Read Engine Configuration. (%d)", SQLCODE );
        throw new CMTException( UERR_DBERROR, m_errMessage );
	}
	
//	strcpy( configRec.lpszAddress, rtrim(RS17_3) );
	configRec.usPort = (unsigned short) RS17_4;
	configRec.amPort = (unsigned short) RS17_5;
}




int CMRLoadData::SaveStatisticsPgm( struct tm *newtime, char *errMessage )
{
EXEC SQL BEGIN DECLARE SECTION;
	char	RS21_1[21];
	short   RS53_1;
	short   RS53_2;
	short   RS53_3;
	short   RS53_4;
	short   RS53_5;
	_SQLINT	RS53_6;
	char    RS53_7[15];
	_SQLINT RS53_8;
	double  RS53_9;
	double  RS53_A;
EXEC SQL END DECLARE SECTION;

    struct sqlca    sqlca;
    int		bExist;

    PGM_LIST  *pPgmPtr = pPgmList;

	RS53_1 = newtime->tm_year+1900;
	RS53_2 = newtime->tm_mon+1;
	RS53_3 = newtime->tm_mday;
	RS53_4 = newtime->tm_wday;
	RS53_5 = newtime->tm_hour;
	RS53_6 = 0;
	RS53_8 = 0;
	RS53_9 = 0.0;
	RS53_A = 0.0;	
	sprintf(RS53_7, "%4d%02d%02d", RS53_1,RS53_2,RS53_3);
	
	while ( pPgmPtr ) {
		if ( pPgmPtr->hit == 0 ) {
			pPgmPtr = pPgmPtr->pNext;
			continue;
		}
		
		strcpy( RS21_1, pPgmPtr->PgmId );
		
//		printf( "PGM : %s    hit(%d)  totTm(%.0lf)   maxTm(%d)\n",  pPgmPtr->PgmId,
//		         pPgmPtr->hit, pPgmPtr->totTm, pPgmPtr->maxTm );



		EXEC SQL SELECT RS53_6, RS53_8, RS53_9, RS53_A
				 INTO  :RS53_6, :RS53_8, :RS53_9, :RS53_A
		         FROM   BRS530TB
		         WHERE  RS21_1 = :RS21_1 AND
			            RS53_1 = :RS53_1 AND
			            RS53_2 = :RS53_2 AND
			            RS53_3 = :RS53_3 AND
			            RS53_4 = :RS53_4 AND
			            RS53_5 = :RS53_5;
		if ( SQLCODE == 0 ) {
			bExist = 1;
		} else {
			bExist = 0;
			
			RS53_6 = 0;
			RS53_8 = 0;
			RS53_9 = 0.0;
			RS53_A = 0.0;
		}
		
		
		RS53_6 += pPgmPtr->hit;
		RS53_9 += pPgmPtr->totWait;		
		RS53_A += pPgmPtr->totTm;
		
		if ( pPgmPtr->maxTm > RS53_8 ) RS53_8 = pPgmPtr->maxTm;
					            

		if ( ! bExist ) {
			EXEC SQL INSERT INTO BRS530TB
		         ( RS21_1, RS53_1, RS53_2, RS53_3, RS53_4, RS53_5, RS53_6, RS53_7, RS53_8, RS53_9, RS53_A )
		         VALUES
		         ( :RS21_1,:RS53_1,:RS53_2,:RS53_3,:RS53_4,:RS53_5,:RS53_6,:RS53_7,:RS53_8,:RS53_9,:RS53_A );
		} else {
			EXEC SQL
			     UPDATE BRS530TB
		         SET   RS53_6 = :RS53_6,
		               RS53_8 = :RS53_8,
		               RS53_9 = :RS53_9,		               
		               RS53_A = :RS53_A
		         WHERE RS21_1 = :RS21_1 AND
			           RS53_1 = :RS53_1 AND
			           RS53_2 = :RS53_2 AND
			           RS53_3 = :RS53_3 AND
			           RS53_4 = :RS53_4 AND
			           RS53_5 = :RS53_5;
		}
		
		if( SQLCODE != 0 ) {			
			if ( ! bExist ) {
				printf("SSP-INSERT(%d) RS21_1[%s], RS53_1[%d], RS53_2[%d], RS53_3[%d], RS53_4[%d], RS53_5[%d], RS53_6[%lld], RS53_7[%s], RS53_8[%lld], RS53_9[%lf], RS53_A[%lf] \n",SQLCODE, RS21_1, RS53_1, RS53_2, RS53_3, RS53_4, RS53_5, RS53_6, RS53_7, RS53_8, RS53_9, RS53_A );     
			}else{
				printf("SSP-UPDATE(%d) RS21_1[%s], RS53_1[%d], RS53_2[%d], RS53_3[%d], RS53_4[%d], RS53_5[%d], RS53_[%lld]6,  RS53_8[%lld], RS53_9[%lf], RS53_A[%lf] \n",SQLCODE, RS21_1, RS53_1, RS53_2, RS53_3, RS53_4, RS53_5, RS53_6,  RS53_8, RS53_9, RS53_A );     
			}
			sprintf(errMessage,"SAVE Program Response Time (%d)", SQLCODE );		
			return SQLCODE;
		}
		
		pPgmPtr->hit = 0;
		pPgmPtr->totTm = 0.0;
		pPgmPtr->maxTm = 0;
		
		pPgmPtr = pPgmPtr->pNext;
    }
    
//  EEXEC SQL COMMIT;

	return 0;
}


int	CMRLoadData::SaveStatisticsRule( struct tm *newtime, RULE_LIST *pRulePtr, char *errMessage )
{
EXEC SQL BEGIN DECLARE SECTION;
	_SQLINT	RS31_1;
	short   RS52_1;
	short   RS52_2;
	short   RS52_3;
	short   RS52_4;
	short   RS52_5;
	_SQLINT	RS52_6;
	char    RS52_7[15];
	_SQLINT RS52_8;
	double  RS52_9;
EXEC SQL END DECLARE SECTION;

    struct sqlca    sqlca;
    int		bExist;

	RS52_1 = newtime->tm_year+1900;
	RS52_2 = newtime->tm_mon+1;
	RS52_3 = newtime->tm_mday;
	RS52_4 = newtime->tm_wday;
	RS52_5 = newtime->tm_hour;
	RS52_6=0;
	RS52_8=0;
	RS52_9=0.0;	
	sprintf(RS52_7, "%4d%02d%02d", RS52_1,RS52_2,RS52_3);
			             
//	printf("Rule : %d    hit(%d)  totTm(%.0lf)   maxTm(%d)\n", pRulePtr->rule_id,	
//				pRulePtr->hit, pRulePtr->totTm, pRulePtr->maxTm );

	RS31_1 = pRulePtr->rule_id;

	EXEC SQL SELECT RS52_6, RS52_8, RS52_9
			 INTO  :RS52_6, :RS52_8, :RS52_9
	         FROM   BRS520TB
	         WHERE  RS31_1 = :RS31_1 AND
		            RS52_1 = :RS52_1 AND
		            RS52_2 = :RS52_2 AND
		            RS52_3 = :RS52_3 AND
		            RS52_4 = :RS52_4 AND
		            RS52_5 = :RS52_5;

	if ( SQLCODE == 0 ) {
		bExist = 1;
	} else {
		bExist = 0;

		RS52_6 = 0;
		RS52_8 = 0;
		RS52_9 = 0.0;			
	}
		
		
	RS52_6 += pRulePtr->hit;
	RS52_9 += pRulePtr->totTm;

//printf("%d [%d][%d][%d][%d][%d][%d][%d][%s][%d][%lf]\n",bExist,
// RS31_1, RS52_1, RS52_2, RS52_3, RS52_4, RS52_5, RS52_6, RS52_7, RS52_8, RS52_9 );
 
	if ( pRulePtr->maxTm > RS52_8 ) RS52_8 = pRulePtr->maxTm;

	if ( ! bExist ) {
			EXEC SQL INSERT INTO BRS520TB
		         ( RS31_1, RS52_1, RS52_2, RS52_3, RS52_4, RS52_5, RS52_6, RS52_7, RS52_8, RS52_9 )
		         VALUES
		         ( :RS31_1,:RS52_1,:RS52_2,:RS52_3,:RS52_4,:RS52_5,:RS52_6,:RS52_7,:RS52_8,:RS52_9 );
	} else {
			EXEC SQL
			     UPDATE BRS520TB
		         SET   RS52_6 = :RS52_6,
		               RS52_8 = :RS52_8,
		               RS52_9 = :RS52_9
		         WHERE RS31_1 = :RS31_1 AND
			           RS52_1 = :RS52_1 AND
			           RS52_2 = :RS52_2 AND
			           RS52_3 = :RS52_3 AND
			           RS52_4 = :RS52_4 AND
			           RS52_5 = :RS52_5;
	}
	
	
	if ( SQLCODE != 0 ) {			        
			sprintf(errMessage,"SAVE Rule Response Time (%d)", SQLCODE );	
		return SQLCODE;
	}
		
		
	pRulePtr->hit = 0;
	pRulePtr->totTm = 0.0;
	pRulePtr->maxTm = 0;

		
    return 0;
}


int  CBRTrace::AddTraceInfo( char *dt, char *pgmId )
{
EXEC SQL BEGIN DECLARE SECTION;
	char RS1C_1[15];
	char RS21_1A[21];
	_SQLINT RS11_1A;
	char RS1D_1[31];	
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE Cursor_TrcInfo CURSOR FOR
			 SELECT RS11_1, RS1D_1
		     FROM   BRS1D0TB
		     WHERE  RS1C_1 = :RS1C_1 AND
			        RS21_1 = :RS21_1A;
			 
    struct sqlca sqlca;
              
	TRC_PGM  *pTrcNew;
	TRC_ITEM *pItem;
	char errMessage[500];

	pTrcNew = (TRC_PGM *) malloc( sizeof(TRC_PGM) );
	if ( ! pTrcNew ) {
      throw new CMTException( SYSERR_MEMORYALLOCATEFAILURE,
                              ERRMSG_MEMORYALLOCATEFAILURE );
	}

	strcpy( pTrcNew->TraceId, dt );
	strcpy( pTrcNew->PgmId, pgmId );

	strcpy( RS1C_1, dt );
	strcpy( RS21_1A, pgmId );

	EXEC SQL SELECT COUNT(*)
             INTO  :RS11_1A
		     FROM   BRS1D0TB
		     WHERE  RS1C_1 = :RS1C_1 AND
			        RS21_1 = :RS21_1A;

    if ( SQLCODE != 0 ) {
        sprintf( errMessage,
                "AddTraceInfo : Select Count. (%d)", SQLCODE );
        throw new CMTException( UERR_DBERROR, errMessage );
    }
    			        
	pTrcNew->itemCnt = (short) RS11_1A;

	if ( pTrcNew->itemCnt == 0 ) {
		pTrcNew->pItem = 0;
		
		pTrcNew->pNext = m_pTrcRoot;
		m_pTrcRoot = pTrcNew;
	
		return 0;
	}


	pItem = (TRC_ITEM *) malloc( sizeof(TRC_ITEM) * pTrcNew->itemCnt );
	if ( ! pItem ) {
      throw new CMTException( SYSERR_MEMORYALLOCATEFAILURE,
                              ERRMSG_MEMORYALLOCATEFAILURE );
	}

	pTrcNew->pItem = pItem;



    EXEC SQL  OPEN  Cursor_TrcInfo;

    if ( SQLCODE != 0 ) {
        sprintf( errMessage,
                "AddTraceInfo : Cursor Open. (%d)", SQLCODE );
        throw new CMTException( UERR_DBERROR, errMessage );
    }

	int i=0;
    while( 1 )
    {
        EXEC SQL
            FETCH       Cursor_TrcInfo
			INTO        :RS11_1A, :RS1D_1;

        if ( SQLCODE == NOTFOUND ) break;
        
		if ( SQLCODE != 0 ) {
            sprintf( errMessage,
                 "AddTraceInfo : Cursor Fetch. (%d)", SQLCODE );
            throw new CMTException( UERR_DBERROR, errMessage );
        }
        
        pItem[i].itemCode = RS11_1A;
        strcpy( pItem[i].strVal, rtrim(RS1D_1) );
	}
	
	EXEC SQL  CLOSE  Cursor_TrcInfo;

	pTrcNew->pNext = m_pTrcRoot;
	m_pTrcRoot = pTrcNew;
			
	return 0;
}


long CMRDataList::SaveTraceInfo( char *dt, char *pgmId )
{
EXEC SQL BEGIN DECLARE SECTION;
	char  RS1C_1B[15];
	char  RS21_1B[21];
	short RS17_1B;
	char  RS1C_Y[18];	
EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	long rc;
	char msg[256];

	m_sect.Lock();

	rc=ConnectLoadDatabase( msg );

	if ( rc == 0 ) {
		strcpy( RS1C_1B, dt );
		strcpy( RS21_1B, pgmId );
		
		RS17_1B = (short) configRec.ulNoServer;
	
		DetailTimeStamp( RS1C_Y );
		RS1C_Y[14] = 0;
printf("RS1C_1B[%s]  RS21_1B[%s]  RS17_1B[%d]  RS1C_Y[%s]\n", RS1C_1B, RS21_1B, RS17_1B, RS1C_Y );

		EXEC SQL
			UPDATE BRS1C0TB
			SET    RS1C_2 = 1,
				   RS17_1 = :RS17_1B,
				   RS1C_Y = :RS1C_Y
			WHERE  RS1C_1 = :RS1C_1B AND
				   RS21_1 = :RS21_1B;
		if ( SQLCODE != 0 ) {			        
			sprintf(msg,"SAVE Trace Result (BRS1C0TB:%d)", SQLCODE);
printf("%d [%s]", SQLCODE, SQLMESSAGE);
			rc = SQLCODE;
		}
		
		DisConnectLoadDatabase();
	}

	m_sect.Unlock();

	if ( rc != 0 ) _WriteLog( _LOG_ERR, msg );
	
	return rc;
}
/*
void CMRDataList::setStartIp( char *ip )
{
		if( ip ){
			sprintf(m_StartIP,"%15s",ip);
		}
}
*/
